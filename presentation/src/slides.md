<!-- .slide data-timing="10" -->
# Разделение <br/> секрета <!-- .element: class="r-fit-text" -->

<cite>Презентацию листать при помощи пробела, с шифтом чтобы назад. За справкой нажми <kbd>?</kbd></cite>

---

# План доклада

<div class="columns">

<div class="col">

1. Введение и простые примеры
2. $(n, n)$-схема, **совершенность**
3. Схема Блэкли, **идеальность**
4. Схема Шамира и атака на неё
5. Вычислительная сложность
6. Сравнение этих двух схем
7. Более сложные **структуры доступа**

</div>
<div class="col" style="max-height: 700px">
	<%= $(cat images/qr.svg) %>
</div>

</div>

Notes:
Мне не хочется давать много определений и свойств кучей, в отрыве от каких-то реальных примеров.
Так их сложнее запомнить и понять, да и мне придётся чаще напоминать о чём идёт речь.

Поэтому то что в обычных учебниках даётся скопом где-то в самом начале, я планирую аккуратно растянуть на всю пару.

Если что, конспект доступен по ссылке

***

# Зачем это надо?
<cite>G. R. BLAKLEY, "Safeguarding cryptographic keys," 1979</cite>

<div class="r-stack r-stretch">
	<div class="fragment"><%= $(cat images/first/01.svg) %></div>
	<div class="fragment"><%= $(cat images/first/02.svg) %></div>
	<div class="fragment"><%= $(cat images/first/03.svg) %></div>
	<div class="fragment"><%= $(cat images/first/04.svg) %></div>
</div>

Notes:

1. Есть важный секрет. _(клик)_ Например, приватный ключ.
Некоторые компании весь бизнес строят на том, что есть ключ и репутация.

2. Конечно, его ни в коем случае нельзя случайно потерять.
Если на главу компании упадёт кирпич, то это не должно быть катастрофой.
Поэтому давайте его разделим между разными людьми _(клик)_

3. _(клик)_ С другой стороны, конкуренты тоже не против получить ключ и что-то сделать.
Что, если один из сотрудников отдаст ключ?
Ну или хакеры там украдут?

4. _(клик)_ Поэтому хочется сделать так, чтобы мы могли восстановить секрет, а враги — нет.

---

# Чего мы хотим?
<cite>G. R. BLAKLEY, "Safeguarding cryptographic keys," 1979</cite>

<div class="r-stack">
<img class="fragment fade-out" data-fragment-index="0" src="images/AllTheThings.png">
<div>

<div class="fragment" data-fragment-index="0">

- $n$ — на сколько кусочков разделили секрет
- $a$ — сколько кусочков мы потеряем
- $b$ — сколько кусочков украдут

</div>
<div class="fragment">

Хотим:
- Чтобы $b$ кусочков было **недостаточно**
- Чтобы $n-a$ кусочков было **достаточно**

</div>
<div class="fragment">

Тогда:
$$
0 ≤ \underline{b < n-a} ≤ n
$$

Отсюда $ n > b + a $,
то есть хотя бы один кусочек должен остаться в полной сохранности

</div>

</div></div>

Notes:
1. Введём пару обозначений. Они только для этого слайда.
	
	- $n$ — сколько сотрудников будут участвовать в схеме;
	- $a$ (от abnegation) — сколько кусочков мы ожидаем потерять;
	- $b$ (от betrayal) — сколько кусочков узнают враги;

	Кстати, если сотрудник вдруг убежал к конкурентам и напрочь отказывается возвращать данные,
	то мы один кусочек относится одноременно к двум категориям.

2. Теперь поймём, чего строго мы хотим.
	Во-первых, чтобы враги не могли узнать секрет. А у них есть $b$ кусочков.
	Во-вторых, сами мы должны суметь восстановить секрет. У нас нету $a$ кусочков, и этого должно хватить.

3. Получаем вот такое неравенство.
	Из него сразу видим, что хотя бы один кусочек должен остаться в целости.
	Нельзя, чтобы половину потеряли, а другую — узнали враги.
	Это вполне естественно: мы должны знать строго больше, чем конкуренты.

---

# Пороговая $(n, k)$-схема

<b>Определение:</b>

Это такая схема разделения доступа, что любые $k$ участников из $n$ могут восстановить секрет.

Другими словами, чтобы получить секрет, нужно хотя бы $k$ участников.

Notes:
Теперь мы можем дать строгое определение одному из главных понятий.

Позже мы добавим несколько других очень важных свойств, и научимся делать не только такие простые схемы.
Но потом.

---

# Пример

Разделим между **тремя** участниками, чтобы только вместе они могли восстановить

<div class="columns">
	<div class="col img_container">
		<img src="images/projections.gif">
	</div>
	<div class="col">

- **Секрет:** { Шар, Куб, Циллиндр }
- **Кусочек:** { Круг, Квадрат }

Любых двух проекций недостаточно, чтобы восстановить секрет.

</div></div>


***
 
<div class="r-stack">

# $(n, n)$-схема

</div>

$k = n$. То есть $n$ участников только <b>все вместе</b> могут получить секрет.

- Идея 1: нарезать секрет на кусочки.
- Недостаток: конкуренты	легко взломают перебором

Notes:
Начнём с построения простейшей схемы. Это не $(n, k)$-схема, а попроще.

Первая идея очень простая. Есть какой-то длинный секрет, мы его можеи просто разрезать на кусочки и раздать участникам. Тогда если они объединятся, то смогут с легкостью восстановить его. Казалось бы, всё хорошо и просто.

Однако здесь есть большой недостаток: конкуренты, если обладают $k-1$ кусочками — на один меньше нужного — запросто могут перебрать все значения оставшегося неизвестного. Их не так уж и много, особенно с ростом числа кусочков.

Мы этого **совсем** не хотим, поэтому давайте строго определим, чего именно мы не хотим.

---

# Совершенность

Хотим, чтобы конкуренты ничего не знали о секрете. Даже если знают $k-1$ кусочек.

По-другому: знание $k-1$ кусочка ничего не даёт <!-- .element: class="fragment" -->

- $s$ — секрет <!-- .element: class="fragment" -->
- $v_i$ — кусочек секрета ($i = 0…n$) <!-- .element: class="fragment" -->
- $H(s \mid v_{i_1}, v_{i_2}, …, v_{i_m})$ — сколько энтропии в $s$, если знаем эти кусочки <!-- .element: class="fragment" -->
- $H(s)$ — сколько энтропии в секрете, если мы совсем ничего про него не знаем <!-- .element: class="fragment" -->

<div class="fragment">

Хотим:
$$
\begin{array}{l l}
H(s \mid v_{i_1}, v_{i_2}, …, v_{i_m}) = H(s), &\text{ при } m < k \\\\
H(s \mid v_{i_1}, v_{i_2}, …, v_{i_m}) = 0,		&\text{ при } m ≥ k
\end{array}
$$

</div>


Notes:
Итак, "хорошие" схемы, в которых конкуренты совершенно ничего не знают о секрете, называются совершенными.

Так и запишем: _(клик)_ знание $k-1$ кусочка ничего не даёт

Теперь давайте попробуем это записать более строго. Для этого надо ввести пару обозначений _(2 клика)_.

Переходим к сложной часть. _(клик)_.

Здесь упоминается энтропия, причём условная. Этот мера неопределнности — как много мы ещё не знаем о значении при таких-то условиях.
Грубо говоря, вот мы знаем столько-то кусочков секрета. Как много надо угадывать, чтобы узнать его весь?
Вспоминая старую плохую схему, если мы знаем много кусочков, то нам остается угадать только один маленький.
Очевидно, это гораздо быстрее чем угадать весь секрет.

_(клик)_. Следующее — количество энтропии в секрете, когда мы вообще ничего не знаем. Грубо, как сложно угадать весь секрет целиком.

Вообще, запросто могу переписать при помощи условных вероятностей, если кому-то не очень понятно.

_(клик)_

И теперь можем записать что именно мы хотим.
- Если мы знаем меньше $k$ кусочков, то мы знаем о секрете ровно столько же, как если бы не знали совсем ничего
- А если мы знаем достаточно кусочков, то знаем и весь секрет полностью. Никаких сомнений в его значении нету.

---

# Настоящая $(n,n)$-схема

Идея:
$ \displaystyle
s = v_1 + v_2 + … + v_n
$

<div class="fragment columns">
<p>Алгоритм: </p>
<div class="col">

0. Пусть $s ∈ 𝔽$
1. Генерируем совершенно случайные $v_2, …, v_n$ тоже из $𝔽$. <!-- .element: class="fragment" -->
2. Находим $v_1 = s - v_2 - … - v_n$	<!-- .element: class="fragment" -->
3. Раздаём эти кусочки участникам <!-- .element: class="fragment" -->

</div></div>

**Почему она совершенная?** <!-- .element: class="fragment" -->

Допустим: знаем $v_1, …, v_{n-1}$ — все кроме (без потери общности) последнего. <!-- .element: class="fragment" -->

<div class="fragment columns">
<p>Тогда: </p>
<div class="col">

1. Есть $|𝔽|$ вариантов для последнего кусочка.
2. Каждый вариант даёт свой уникальный $s$. <!-- .element: class="fragment" -->
3. Угадать один кусочек из $|𝔽|$ также сложно, как угадать секрет (тоже из $𝔽$). <!-- .element: class="fragment" -->

</div></div>

Notes:
Теперь реализуем подзодящую схему. Хотим секрет разделить между $n$ участниками.
Идея очень проста: пусть все кусочки в сумме дают этот самый секрет.

_(клик)_ Во-первых, договоримся что секрет взялся из какого-то поля $𝔽$. Совершенно не важно из какого.

_(клик)_ Для реализации достаточно сгенерировать все числа кроме одного. Они должны быть из того же поля.

_(клик)_ Затем остаётся единственым образом определить одно оставшееся.

_(клик)_ И всё, кусочки готовы.

_(клик)_ Следующий шаг: покажем что она действительно совершенна.

_(клик)_ Допустим самое худшее — знаем все кусочки кроме одного.

_(клик)_ Тогда мы можем попытаться найти последний подбором.

_(клик)_ Но их ровно столько, сколько и возможных секретов.

_(клик)_ Получается, что ровно с тем же успехом мы могли бы пытаться угадать секрет.
	Видно, что знания кусочков никак не помогают. А значит схема совершенна.

---

И секрет, и кусочек из одного поля — они содержат одинаково информации.

<div class="fragment">

# Теорема
<cite>E. Karnin, J. Greene and M. Hellman, "On secret sharing systems", 1983</cite>

Пусть схема совершенная, а $v_i∈V$ — кусочек секрета $s∈S$.<br/>Тогда $H(V_i) ≥ H(s)$.

</div><div class="fragment">

**Следствие:** Если $s$ случайно, то $|V| ≥ |S|$.

</div><div class="fragment">

**Доказательство**

TODO!!!

</div>

Notes:
Заметили, что размер кусочка вырос? В плохой и неправильной схеме он был в $n$ раз меньше секрета, а теперь совпадает с ним?

Так вот, существует подходящая теорема _(клик)_.
Она говорит, что у совершенной схемы каждый кусочек не может содержать меньше информации, чем целый секрет.

У неё есть довольно интересное следствие _(клик)_.
А именно, мощность множества с кусочком обычно не может быть меньше, чем множество с секретом.
На практике это означает, что если у вас секрет занимает столько-то бит, то и каждый кусочек будет не меньше.

Теперь давайте это докажем _(клик)_.


***

# Схема Блэкли
<cite>G. R. BLAKLEY, "Safeguarding cryptographic keys" 1979</cite>

<div class="columns">
<div class="col">

Это $(n, k)$-схема. Из $n$ участников достаточно только $k$.

Описана Джорджем Блэкли в начале июня 1979 года. 

</div>
<div class="col">
	<img src="images/george-blakley.jpg">
</div></div>

Notes:
Мы реализовали простейшую $(n, n)$-схему, но она не даёт права потерять никакой кусочек.
Обязательно все должны пристутствовать. Её на самом деле можно улучшить, но гораздо полезнее воспользоваться нормальной схемой Блэкли.

---

## Схема Блэкли

**Идея:** $k$ гиперплоскостей пересекаются в $k$-мерном пространстве в точке.


<div style="height: 350px">
	<%= $(cat images/planes.svg) %>
</div>

<div class="fragment">

**Алгоритм**:

0. Секрет $s∈𝔽$. <span class="fragment">Возьмём пространство $𝔽^k$</span>
1. Выберем случайные и независимые $x_2, x_3, …, x_k$ <!-- .element: class="fragment" -->
2. Секретная точка: $(s, x_2, x_3, …, x_k)$ <!-- .element: class="fragment" -->
3. Провести через неё $n$ случайных гиперплоскостей и раздать их участникам.	<!-- .element: class="fragment" -->

</div>

Notes:
Идея этой схемы заключается в том, что гиперплоскости пересекаются только в одной точке.
На примере трёхмерного пространства как раз показано, что две плоскости пересекаются по прямой, а три — уже в точке.

_(клик)_ Теперь пройдёмся по алгоритму. Как и раньше, возьмём секрет из поля $𝔽$. _(клик)_ К нему сразу добавляем $k$-мерное пространство, в котором и будет всё происходить.

_(клик)_ Дальше снова генерируем случайные $k-1$ точку. Удивительно, но это продолжает совпадать с простейшей схемой.

_(клик)_ И вот теперь начались отличия. Как мы помним, плоскости перескаются в точке. Значит какая-то точка пространства должна кодировать секрет. Ну и вот мы её выбрали. Одна её координата содержит секрет, а остальные выбраны совершенно случайно.

_(клик)_ Дальше мы должны провести через эту точку $n$ произвольных плоскостей. Вот и всё.

---

## Схема Блэкли: совершенность

- $k-1$ плоскость, пересекается по прямой ($\cong 𝔽$)
- Но нас интересует только одна координата <!-- .element: class="fragment" data-fragment-index="0" -->

<div style="height: 600px;">
	<%= $(cat images/line_project.svg) %>
</div>

- На прямой столько же точек, сколько и значений секрета! <!-- .element: class="fragment" data-fragment-index="1" -->


Notes:
Давайте покажем, почему эта схема совершенна.
То есть что даже зная $k-1$ плоскость, угадывать секрет не становится легче.

С одной стороны, вполне известно что секретная точка лежит на прямой.
Казалось бы, это облегчает задачу. И это было бы так, если бы были важны все координаты точки.

Поскольку сам секрет находится в первой координате точки, то можно рассмотреть только эту координату у прямой.

И тогда будет легко видеть, что прямая содержит столько же точек, сколько и ось координат.
То есть столько же точек, сколько и значений секрета.

---

## Схема Блэкли

**Секрет**: $s ∈ 𝔽$.

**Кусочек**: $k$-мерная плоскость

<div class="fragment">
$$
A_1x_1 + A_2x_2 + … + A_kx_k + A_0 = 0
$$
</div>

<div class="fragment">
$$
x_1 + \frac{A_2}{A_1}x_2 + … + \frac{A_k}{A_1}x_k + \frac{A_0}{A_1} = 0
$$
</div>

<div class="fragment">
$$
x_1 + B_2x_2 + … + B_kx_k + B_1 = 0, \quad B_i ∈ 𝔽
$$
</div>

<div class="fragment">

**Плоскость**: набор $(B_1, B_2, …, B_k) ∈ 𝔽^k$

Но секрет-то только $𝔽$!

</div>

Notes:

Теперь посмотрим что же у нас получилось.
А получились плоскости. Каждую из них можно записать таким образом: _(клик)_.
Но вообще-то говоря, их можно привести к каноническому виду: _(клик)_.
Таким образом, каждая плоскость записывается при помощи ровно $k$ коэффициентов, каждый из нашего поля: _(клик)_.

В этой схеме так получилось, что размер кусочка в $k$ раз больше, чем размер самого секрета.

***

# Идеальность

Секрет $s ∈ S$, кусочек $v_i ∈ V$.

- Из теоремы: $H(v_i) ≥ H(s)$
- Если $H(v_i) = H(s)$, то схема идеальна

Схема идеальна тогда, когда кусочек содержит ровно столько же информации, сколько и секрет.

Notes:
Теперь давайте определим новое свойство.

Идеальность — когда размер кусочка ровно такой же, как и размер секрета.
Если схема совершенна, то меньше он быть и не может, мы это доказали раньше.

Поскольку в схеме Блэкли размер кусочка гораздо больше, то она не идеальна. Совершенна, но не идеальна.

---

## Неправильная схема

Хотим сделать схему Блэкли её идеальной.

- Секрет хранится только в одной координате.	<!-- .element: class="fragment" -->
	* $s ∈ 𝔽$
- А кусочек гораздо больше <!-- .element: class="fragment" -->
	* $v_i ∈ 𝔽^k$
- Идея: распределить секрет по всем координатам: $s ∈ 𝔽^k$ <!-- .element: class="fragment" -->
	* Нельзя: на прямой всего лишь $|𝔽|$ точек, хотя вариантов секрета $|𝔽|^k$ <!-- .element: class="fragment" -->
	* Такая схема не будет совершенной <!-- .element: class="fragment" -->

<div style="height: 300px">
	<%= $(cat images/planes.svg) %>
</div>

Notes:
Теперь давайте попробуем модифицировать схему таким образом, чтобы она стала идеальной.

_(клик)_ Во-первых, секрет хранится только в одной координате.
_(клик)_ Но вот размер кусочка гораздо больше, и нам это не нравится.

_(клик)_ Что будет, если распределить секрет по всем координатам точки? Ведь тогда как раз размеры сравняются.
	Как думаете, так можно сделать?

_(клик)_ Но тогда $k-1$ плоскость пересекается по прямой. И на этой прямой уже гораздо меньше точек.
А значит секрет становится гораздо проще найти, даже если не знать все кусочки.
_(клик)_ Такая схема будет несовершенной.


Именно такой вариант схемы Блэкли почему-то описан на русской википедии и какой-то криптовики.
Эта схема аналогична самой первой, где мы просто нарезали секрет на кусочки. Конечно, это нам не подходит.

---

## Модифицированная схема
<cite>Brickell, E. F. "Some ideal secret sharing schemes", (1989, April)</cite>

- Кусочек: целая плоскость ($v_i ∈ 𝔽^k$). Слишком большой.

- **Опубликуем** все коэффициенты плоскостей кроме одного.

- Тогда кусочек: один коэффициент плоскости ($v'_i ∈ 𝔽$). Размер уже совпадает с секретом.

<div class="fragment">

Совершенность?

- Пусть мы полностью знаем $k-1$ плоскость
- И также мы знаем коэффициенты $k$-ой.
- Но не знаем коэффициент $a$.
- Где тогда может лежать секрет (одна из координат точки)?

Покажем, что для любого значения $s$ существует единственный $a$.<br/>
То есть существует взаимно-однозначное соответствие.

</div>

Notes:
Вообще-то говоря, схему несложно переделать таким образом, чтобы она стала одновременно и совершенной, и идеальной.

Проблема заключается в том, что размер кусочка — целая плоскость — слишком большой.
Его можно довольно легко уменьшить, просто-напросто опубликовав некоторые коэффициенты.
Они становятся публичной информацией и уже не влияют на размер секретного кусочка.

Но теперь стоит перепроверить совершенность. _(клик)_ То есть то, что знание многих кусочков никак не помогает найти секрет.

---

## Модифицированная схема
<cite>Коннов Илья, 2021</cite>

1. Из знания $k-1$ плоскости мы знаем, что секрет лежит на прямой.
2. Также у нас есть $k-1$ коэффициент другой плоскости.
3. Допустим, что секрет находится в точке $P$.
4. Тогда пусть наша немного неизвестная плоскость проходит через неё.
	$$
	ax_1 + C_2x_2 + C_3 x_3 + … + C_k x_k + C_1 = 0 \bigg|_{x = P} \\\\
	\implies a = \frac{C_1 - C_2P_2 - … - C_kP_k}{x_1}
	$$
5. Таким образом, для каждого секрета ($≈P$) существует коэффициент, причём для разных $P$ разный.

Значит угадывать коэффициент ровно также сложно, как и угадывать секрет. Схема совершенна!

Notes:
В целом, можно было бы практически также сказать, что у нас есть не коэффициенты плоскости, а $k-1$ точка, через которые плоскость проходит, все в первой координате содержат ноль.

***

# Многочлен Лагранжа

<div class="fragment">

**Хотим**: провести многочлен не более $n-1$ степени через $n$ точек

Например, **прямая** — многочлен первой степени — легко строится по **двум** точкам.

**Дано**: точки $(x_1, y_1), (x_2, y_2), …, (x_n, y_n)$.

</div>

<div class="fragment">

**Очень простая идея:**

Можно составить СЛАУ на $c_i$, подставив точки в $c_0 + c_1 x + c_2 x^2 + … + c_{n-1}x^{n-1}$.

Здесь $n$ неизвестных, $n$ уравнений, следовательно решение единственно.

</div>

Notes:
Теперь немного поговорим про многочлен Лагранжа. Он нам потом пригодится. _(клик)_

Вообще, довольно известный факт, что через $n$ точек можно построить многочлен $n-1$ степени.
Кто-то может в двух словах показать как? Не через многочлен, это можно сделать просто.

... _(клик)_ ...

Но оно нас немного ограничит позднее, так что давайте всё-таки рассмотрим многочлен Лагранжа. Он тоже очень простой.

---

## Очевидное решение

Просто скажем следующее:

$$
f(x) = \begin{cases}
y_1, &x = x_1 \\\\
y_2, &x = x_2 \\\\
… \\\\
y_n, &x = x_n \\\\
\text{что-нибудь},& x \notin \\{x_1, x_2, …, x_n\\}
\end{cases}
$$

<div class="fragment">

И если бы у нас была такая функция:
$$
\ell_j(x) = \begin{cases}
1,& x = x_j \\\\
0,& x = x_i, i≠j \\\\
\text{что-нибудь}& x \notin \\{x_1, x_2, …, x_n\\}
\end{cases}
$$

</div>

<div class="fragment">

Тогда бы мы разбили на сумму:

$$
f(x) = y_1 \ell_1(x) + y_2\ell_2(x) + … + y_n \ell_n(x)
$$

</div>

Notes:

Итак, во-первых, мы хотим как-то построить вот такую функцию.
Важно лишь то, чтобы она проходила через некоторые точки, а всё остальное — как получиится.

_(клик)_ Но строить такую большую функцию довольно сложно, поэтому давайте упростим себе жизнь и сделаем функцию $\ell$, она поменьше.
В одной из нужных точек она равна единице, в других нужных — равна нулю, а во всех остальных нас значение не волнует.

_(клик)_ И если мы вдруг сможем построить такую функцию $\ell$, то первую большую можно будет легко разбить на вот такую сумму.
Здесь довольно очевидно, что она будет проходить через все нужные точки.
Для каждой интересующей нас точки только одна из $\ell$ будет равна единице, а все остальные равны нулю.
И эту единственную единицу мы умножаем на требуемое значение функции в нужной нам точке. Вот и всё.

---

## Такая функция есть!
Напомню:
<span class="r-stack">
<span class="fragment fade-out" data-fragment-index="1">$
	\ell_j(x) = \begin{cases}
	1,& x = x_j \\\\
	0,& x = x_i, i≠j \\\\
	\text{что-нибудь},& x \notin \\{x_1, x_2, …, x_n\\}
	\end{cases}
$</span>
<span class="fragment fade-in-then-out" data-fragment-index="1">$
	\ell_j(x) = \begin{cases}
	\color{orange}{1},& \color{orange}{x = x_j} \\\\
	0,& x = x_i, i≠j \\\\
	\text{что-нибудь},& x \notin \\{x_1, x_2, …, x_n\\}
	\end{cases}
$</span>
<span class="fragment fade-in-then-out" data-fragment-index="2">$
	\ell_j(x) = \begin{cases}
	1,& x = x_j \\\\
	\color{orange}{0},& \color{orange}{x = x_i, i≠j} \\\\
	\text{что-нибудь},& x \notin \\{x_1, x_2, …, x_n\\}
	\end{cases}
$</span>
<span class="fragment fade-in-then-out" data-fragment-index="3">$
	\ell_j(x) = \begin{cases}
	1,& x = x_j \\\\
	0,& x = x_i, i≠j \\\\
	\color{orange}{\text{что-нибудь}},& \color{orange}{x \notin \\{x_1, x_2, …, x_n\\}}
	\end{cases}
$</span>
</span>

<div class="fragment" data-fragment-index="0">

Выглядит она как произведение дробей:

$$
\ell_j({\color{red} x}) = \prod_{\substack{i=0\\\\i≠j}} \frac{{\color{red} x} - x_i}{x_j - x_i}
$$

</div>

- Если $x = x_j$, то очевидно каждая дробь равна $1$, и вся функция тоже. <!-- .element: class="fragment fade-in-then-semi-out" data-fragment-index="1" -->
- Если $x = x_i, i≠j$, то найдётся $i$, такой что $x_i = x$. А значит один из числителей будет таким $x_i - x_i = 0$. И всё произведение обнулится.	<!-- .element: class="fragment fade-in-then-semi-out	" data-fragment-index="2" -->
- Все точки различны и $j≠i$, а значит мы не делим на ноль.	<!-- .element: class="fragment fade-in-then-semi-out	" data-fragment-index="3" -->

Notes:
К счастью, такая маленькая функция $\ell$ существует, и сейчас покажу как она работает.

_(клик)_ Выглядит она как вот такое сложное произведение дробей. Здесь $i$ из произведения пробегает по всем, кроме $j$.

_(клик)_ Смотрим на первое требование. Функция при $x=x_j$ должна быть равна единице. Здесь это вполне выполняется.
	Каждая дробь будет иметь один и тот же числитель и знаменатель, поэтому все они равны единице.

_(клик)_ Двигаемся дальше. Надо чтобы во всех остальных точках функция была равна нулю.
Здесь это обеспечивается за счёт того, что мы перебираем все эти остальные точки и вычитаем $x_i$ из аргумента.
Тогда в этих точках хотя бы один числитель обнулится, а вместе с ним обнулится и всё произвдение.

_(клик)_ Ну и наконец, функция везде определена. Поскольку предполагается, что все иксы различны, то мы на ноль никогда не делим.

---

## Итог

Интерполяционный многочлен Лагранжа:

$$
f({\color{red} x}) = \sum_{j=1}^n y_j \prod_{\substack{i=0\\\\i≠j}} \frac{{\color{red} x} - x_i}{x_j - x_i}
$$

- Проходит через точки $(x_1, y_1), …, (x_n, y_n)$
- Степень не больше $n$

Notes:
Ну и вот итог. Интерполяционный многочлен Лагранжа выглядит вот таким вот образом. Как мы показали, он проходит через все нужные точки (если они различны).

Поскольку в кажом произведении не больше $n-1$ линейного множителя, то и весь многочлен тоже не больше $n-1$ степени.

Остается только разобраться с единственностью.

---

## Единственность

> Через $n$ точек проходит единственный многочлен степени не больше $n-1$.

**Доказательство:**

- Пусть $f(x)$ и $q(x)$ — два таких многочлена
- Тогда $f(x) - q(x)$ имеет не меньше $n$ нулей — в точках через которые они проходят.
- А ещё $f(x) - q(x)$ тоже степени не больше $n-1$.
- Но $f(x) - q(x)$ не может иметь $n$ нулей! Это же больше его степени.
- А значит $f(x) - q(x) = 0$ ∎

Notes:
Доказательство очень простое, его можно прочитать на доске.

Действуем от противного. Пусть есть два многочлена, которые оба проходят через одни и те же $n$ точек.

Тогда рассмотрим их разность. Она будет тоже многочленом степени не больше $n-1$, как и исходные два.

Но по основной теореме алгебры такой многочлен не может иметь более чем $n-1$ нуль.
А здесь у нас их $n$, поскольку $f$ и $q$ точно совпадают в $n$ точках.

Получаем что $f - q$ равно нулю, то есть $f = q$, что и требовалось доказать.

***

# Схема Шамира
<cite>Shamir, A. How to share a secret.</cite>

**Идея:** через $k$ точек можно провести единственый многочлен. Пусть $s = f(0)$.

<iframe data-preload class="r-stretch" style="filter: invert(100%);" data-src="https://www.desmos.com/calculator/8qgjticahg?embed"></iframe>

Кусочки — точки на многочлене. Секрет — его значение в нуле.

Notes:
Итак, переходим к практически полезной схеме. Схема Шамира была опубликована в ноябре 1979 года криптографом Ади Шамиром, через примерно полгода после схемы Блэкли. Та была представлена в начале июня.

Идея схемы Шамира очень проста.
По $k$ кусочкам мы всегда можем построить единственный многочлен степени $k-1$.
И секрет тогда будет равен его значению в нуле.
А вот по $k-1$ кусочку уже нельзя ничего говорить о том, какой может быть многочлен и где находися секрет.

---

## Реализация
<cite>Shamir, A. (1979). How to share a secret.</cite>

1. Выбрать достаточно большое поле (секрет должен поместится).
2. Сгененерировать случайный многочлен степени $k-1$
	$$f(x) = c_1x^{k-1} + c_2x^{k-2} + … + c_{k-2}x^2 + c_{k-1} x + s$$
	Свободный член равен $s$, благодаря чему $f(0) = s$
3. Посчитать значения в точках $1,2,3,…,n$ и раздать их. То есть $v_i = f(i)$. Координата $x$ точек — публичная информация.
4. По $k$ любых из этих $n$ точек можно построить $f$ обратно. Тогда $s = f(0)$.

Notes:
Подробная схема такова.

1. Сначала надо выбрать какое-то поле. Чаще всего используется поле вычетов по большому простому модулю. Но вообще-то говоря, сгодится любое. Просто чем меньше поле, тем меньше значений для секрета и тем легче взломать перебором. Хотя обычно на размер секрета влиять нельзя. Также в маленьком поле будет мало точек, которые можно раздать. Напрмиер, в $ℤ_7$ никак нельзя выбрать 10 разных точек на многочлене.

2. Затем генерируем случайные коэффициенты для многочлена. Здесь они обозначены как $c_i$.
	Свободный же член делаем равным $s$, засчёт чего можно очень легко сделать так, чтобы $f(0) = s$.

	Вообще-то говоря, не обязательно использовать именно $x=0$ для секрета, просто иначе генерация многочлена становится немного менее тривиальной. Можно, например, сгенерировать $k-1$ точку и интерполировать многочлен через них и точку с секретом. Но мы так делать не будем, у нас всегда секрет в нуле.

3. Дальше надо выбрать любые $n$ точек на многочлене и посчитать их.
	Обычно выбирают просто по порядку $x = 1, 2, 3$ и т.д., но вообще-то говоря это совершенно не важно, ведь здесь эти координаты — публичная информация.

4. Восстановление секрета происходит очень просто. Нужно всего лишь выбрать любые $k$ точек и построить многочлен обратно.
	Ну а дальше секрет легко находится. Вообще-то говоря, лучше не искать многочлен отдельно, а просто подставить $x=0$ d многочлен Лагранжа и посчитать значение в этой точке.

---

## Совершенность
<cite>G. R. BLAKLEY, "Safeguarding cryptographic keys," 1979</cite>

> For example, a polynomial
> of degree $b$ can be reconstructed from its values at $b+1$
> points. But already its values at any $b$ points tell a lot about
> it. It can also be reconstructed from the values of its $0$th
> through $b$th Taylor coefficients at a point. But already the
> values of any $b$ of these $b+1$ numbers tell a lot about it.

— Блэкли о многочленах <!-- .element: style="text-align: right;"> -->

Notes:
Перед тем как мы двинемся дальше, вот тут вот цитата из работы Блэкли по его схеме.

Вот он говорит, что многочлен степени $b$ может быть восстановлен по $b+1$, но даже только $b$ уже дают очень много информации о многочлене. Как вы думаете, он прав?

Нет, в общем случае мы не получаем никакой дополнительной информации о многочлене.

---

## Совершенность

Мы знаем $k-1$ кусочек. Хотим узнать какой может быть секрет.

- Не используя знания кусочков, можем перебрать все секреты: их $|𝔽|$ штук.
- Перебор вариантов последнего кусочка не легче: тоже $|𝔽|$ вариантов.
- Правда ли, что все секреты возможны?
- Можем ли построить многочлен степени $k-1$, проходящий через всякий секрет и через известные $k-1$ точек?
- Конечно можем! Даны $k$ точек, надо многочлен степени $k-1$. Это легко и всегда возможно.

Значит схема совершенна!

Notes:
Хотим показать совершенность.
Напомню: это когда знание $k-1$ кусочка не даёт совершенно никакой информации о том, какой может быть секрет.

С одной стороны, мы всегда можем перебрать всевозможные секреты. Даже когда вообще ничего не знаем.
Надо как-то показать, что если знаем много точек, то этот перебор никак нельзя облегчить.
Например, выкинув заведомо невозможные секреты.

То есть надо показать, что через каждый из секретов можно провести какой-то многочлен, который к тому же будет проходить через уже известные нам точки.

Всё сводится к тому, что у нас есть $k-1$ точка кусочков и есть ещё одна точка секрета. Как я показывал раньше, через $k$ точек всегда можно провести многочлен степени $k-1$. Именно такой и нужен по схеме.

Значит любой из секретов одинаково возможен, как было бы если мы вообще ничего не знали. Схема совершенна!

И кстати, каждый из секретов соответствует ровно одному значению последнего кусочка. Это легко доказать, но я не буду.

---

## Идеальность

— Размер кусочка равен размеру секрета? <br/>
— Конечно!<br/>
— Значит идеальна. Вот и хорошо.

Notes:
Ну здесь всё очень просто. Секрет – значение многочлена в некоторой точке. Кусочек — тоже значение, но уже в другой точке.
Конечно же у них будет один и тот же размер. А знчит схема идеальна.

---

## TODO: О натуральных числах

***

# Атаки
<cite>Tompa, Martin, and Heather Woll. "How to share a secret with cheaters." (1989)</cite>

С внешними врагами разобрались, схемы совершенны.

Но схемы разделения применяются когда нет доверия даже участникам!

Участники могут назвать вместо настоящего кусочка что-то своё. И никто не узнает!

А если сговорилось $k-1$ участников…

Notes:
Итак, переходим ко второй части. Как говорилось в самом начале, участники схемы заросто могут предать. И ничего им не может помешать сказать вместо своего настоящего кусочка что-то другое. В целом, участники больше ничего не могут сделать.

Вообще-то говоря, самый худший случай — почти все участники участвуют в заговоре и хотят как-то обмануть посследнего. Но мы будем рассматривать только простой случай со схемой Шамира.

---

# Защита в общем случае

**Проблема**: нельзя заметить атаку

**Решение**: Опубликовать всем хеш секрета

**Проблема**: формально, никто не гарантирует необратимость хеш-функции.

---

## Атака на схему Шамира
<cite>Tompa, Martin, and Heather Woll. "How to share a secret with cheaters." (1989)</cite>

**Имеется:** один участник — заговорищик

**Хочется:** узнать секрет одному, так чтобы другие его не знали

**Можем:** назвать другое число в качестве своего кусочка

**Знаем:** координаты $x$ других участников

Как?

<div class="fragment">

**Идея:** сдвинуть свой кусочек так, чтобы секрет от этого **предсказуемо** сдвинулся

</div>

Notes:
Теперь буду показывать, как действительно провести настоящую атаку. Достаточно одного заговорщика.

Цель такой атаки заключается в том, чтобы обмануть остальных участников — заставить их поверить в ложный секрет.
А заодно и узнать настоящий секрет самим.

При этом мы можем влиять только на свой кусочек, а знаем только лишь его и публичную информацию: где примерно находятся точки остальных участников. То есть какие $x$ они имеют, значений не знаем.

_(клик)_

Оказывается, есть способ посчитать, как надо сдвинуть свой кусочек, чтобы при этом восстановленный секрет изменился некоторым конкретным способом.

---

## Реализация атаки
<cite>Tompa, Martin, and Heather Woll. "How to share a secret with cheaters." (1989)</cite>

**Обозначения:** <br/>
- $(x_1, y_1)$ — «наша» точка (без потери общности первая).
- $f$ — «настоящий» многочлен, проходит через $(x_1, y_1), (x_2, y_2), …, (x_k, y_k)$.
- $y_1'$ — поправленное значение «нашего» кусочка. Хотим его найти.
- $f'$ — «ложный» многочлен, проходит через ложную точку $(x_1, y_1')$.
- $s = f(0)$ и $s' = f'(0)$ — восстановленные секреты: «настоящий» и «ложный» соответсвенно
- $t$ — насколько мы хотим изменить секрет. $s' = s + t$

<div class="columns">
	<p><b>Атака:</b></p>
	<div class="col">

Проводим многочлен $g(x)$ через $(0, t), (x_2, 0), (x_3, 0), …, (x_k, 0)$. Тогда $y_1' = y_1 + g(x_1)$.

То есть многочлен в нуле (где секрет) равен $t$, а в точках других участников равен нулю.
Тогда чтобы увеличить секрет на $g(0)$ надо прибавить к первому кусочку $g(x_1)$.

</div></div>

---

<cite>Коннов Илья, 2021</cite>
$g(x)$ проходит через $({\color{orange} 0}, t), (x_2, 0), (x_3, 0), …, (x_k, 0)$. Тогда $y_1' = y_1 + g(x_1)$<br/>
Используем формулу Лагранжа: $\displaystyle g({\color{red} x}) = \sum_{j=1}^n y_j \prod_{\substack{i=1\\\\i≠j}} \frac{{\color{red} x} - x_i}{x_j - x_i}$<br/>
Здесь из-за $y_j = 0$ обнулится всё кроме $\displaystyle g({\color{red} x}) = t \prod_{i=2}^k \frac{{\color{red} x} - x_i}{{\color{orange} 0} - x_i}$<br/>
Тогда $\displaystyle g(x_1) = t \prod_{i=2}^k \frac{x_1 - x_i}{{\color{orange} 0} - x_i}$<br/>
Теперь в $\displaystyle f({\color{red} x}) = \sum_{j=1}^n y_j \prod_{\substack{i=1\\\\i≠j}} \frac{{\color{red} x} - x_i}{x_j - x_i}$ вместо $y_1$ поставим $y_1' = y_1 + g(x_1)$<br/>
$$
\displaystyle s' = f'({\color{orange} 0})
	= \underbrace{
		\left(\sum_{j=1}^n y_j \prod_{\substack{i=1\\\\i≠j}} \frac{{\color{orange} 0} - x_i}{x_j - x_i} \right)
	}\_{f({\color{prange} 0}) = s}
	+ \underbrace{
		\left(t \prod_{i=2}^k \frac{x_1 - x_i}{{\color{orange} 0} - x_i}\right)
	  \left(  \prod_{i=2}^k \frac{{\color{orange} 0} - x_i}{x_1 - x_i}\right)
	}_{t}
$$

Notes:
Собственно, ради этого момента я и рассказывал про многочлен Лагранжа.

Сначала мы проводим многочлен $g(x)$ через точки как было описано раньше. Для этого используем формулу Лагранжа.

Поскольку у нас там везде нули, то от суммы останется только одно слагаемое, соответсвует точке $(0, t)$ — как мы меняем секрет.

Дальше нас интересует только $g(x_1)$. Мы не требовали какого-то конкретного значения в точке.

Это $g(x_1)$ мы прибавляем к старому кусочку, $y_1 = f(x_1)$. Тем самым получаем $y_1'$ — подделанный кусочек.

И теперь хотим посчитать что за секрет получится, если в схеме использовать такой неправильный кусочек.
Для этого восстанавливаем многочлен при помощи всё той же формулы Лагранжа. Нас интересует только значение в нуле.

Если раскрыть скобки, то получаем то что написано внизу.
А там получился как раз настоящий секрет, плюс какая-то штука, которая сокращается ровно в $t$.

То есть мы сумели прибавить $t$ к значению секрета. Не удивительно ли?

---

## Защита от этой атаки
<cite>Tompa, Martin, and Heather Woll. "How to share a secret with cheaters." (1989)</cite>

Очень просто:

1. Выбирать $x_i$ для кусочков случайно среди всех возможных.
2. Сделать эту информацию секретной.

Тогда кусочек содержит всю пару $(x, y)$ и схема больше не идеальна.

Notes:
Защитится от этой атаки довольно просто. Надо всего лишь засекретить информацию о том, где находятся кусочки.
Тогда атакующий не сможет предсказуемо изменить секрет и атака не удастся.

Строго говоря, он всё также может обмануть участников, но уже не столь предсказуемо.

TODO: Авторы работы говорят, что эта защита неидеальна и позволяет лишь заметить атаку, но атакующий всё равно узнает секрет. Однако там написано что-то очень странное, я не понял.


***

# Вычислительная сложность

Идеальная и совершенная схема Блэкли требует найти одну из координат точки пересечения плоскостей.

Схема Шамира требует нахождения свободного члена многочлена.

Обе эти задачи требуют нахождения одной неизвестной в СЛАУ.

1. Метод Крамера: посчитать два определителя —- 

***

## Схема Шамира и схема Блэкли

Идеальная и совершенная модификация схемы Блэкли **очень** похожа на схему Шамира.

- **Блэкли**: использует произвольное $k$-мерное пространство<br/>
  **Шамир**:  использует пространство многочленов степени не выше $k-1$

- **Блэкли**: кусочек — гиперплоскость размерности $k-1$<br/>
  **Шамир**:  кусочек — **пучок** многочленов, проходящих через точку

- **Блэкли**: секрет содержится в точке пересечения гиперплоскостей<br/>
  **Шамир**:  секрет содержится в секретном многочлене — пересечении всех пучков

- **Блэкли**: сам секрет — одна из координат секретной точки<br/>
  **Шамир**:  сам секрет — одно из значений секретного многочлена


***

# Сложные структуры доступа

***

# Спасибо за внимание!

Источники:
