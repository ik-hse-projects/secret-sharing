<!doctype html>
<html>
  
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="../style.css">
    
<link href="https://rawcdn.githack.com/iliakonnov/linlibertine/718d3ae934bec3bb1cb173af93ad22a42362c266/linlibertine.css" rel="stylesheet"> 
<style>body { font-family: "Linux Libertine", serif; }</style> 
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.css" integrity="sha384-zTROYFVGOfTw7JV7KUu8udsvW2fx4lWOsCEDqhBreBwlHI4ioVRtmIvEThzJHGET" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.js" integrity="sha384-GxNFqL3r9uRJQhR+47eDxuPoNE7yLftQM8LcxzgS4HT73tp970WS/wV5p8UzCOmb" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/contrib/auto-render.min.js" integrity="sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl" crossorigin="anonymous" onload="renderMathInElement(document.body);"></script>

  </head>
  
  <body class="ck-content">
     <h1>Схема Блэкли</h1>

    <p>Схема разделения секрета на основе многомерных пространств.</p>
    <ul>
      <li><a href="https://ru.wikipedia.org/wiki/Векторная_схема_разделения_секрета">https://en.wikipedia.org/wiki/Secret_sharing#Blakley's_scheme</a>
      </li>
      <li>G. R. BLAKLEY, "<a href="https://ieeexplore-ieee-org.proxylibrary.hse.ru/document/8817296">Safeguarding cryptographic keys</a>,"
        1979 International Workshop on Managing Requirements Knowledge (MARK),
        1979, pp. 313-318, doi: 10.1109/MARK.1979.8817296.</li>
    </ul>
    <h2>Отступление об источниках</h2>
    <p>На русской википедии есть отдельная статья, но статься на ней содержит
      этот <strong>ужасный</strong> абзац. Я даже не поленился его сюда скопировать:</p>
    <blockquote>
      <p style="margin-left:0px;"><strong>Несовершенная схема</strong>: Количество участника увеличит, номер
        возможностей для секретной точкой снизит. Например, для <i>t</i>&nbsp;−&nbsp;1
        участников&nbsp;знают линии, в которой лежит секретная точка.</p>
      <p style="margin-left:0px;"><strong>Отсек схемы</strong>: Участники&nbsp; делятся на подгруппы называемых&nbsp;отсеков.
        Чтобы получить секрет, кворум отсеков требуется, но для отсек&nbsp;участвовать
        в кворуме, другой кворум акций&nbsp;требуется.</p>
      <p style="margin-left:0px;"><strong>Многоуровневые схемы</strong>: Участники делятся на две упорядоченных
        уровнях. Для восстановления секрет, меньше кворума требуется более высокий
        уровень. Кроме того, каждый высший&nbsp;уровнь участники может заменить
        на нижнего уровня участники.</p>
      <p style="margin-left:0px;">Некоторые участники не могут получить секрет.</p>
    </blockquote>
    <p style="margin-left:0px;">Во-первых, тут отвратительный гуглоперевод, а во-вторых, тут фактическая
      ошибка. Схема <strong>является совершенной</strong> при правильной её реализации.</p>
    <p
    style="margin-left:0px;">В английской же википедии очень кратко изложена идея схемы и основные
      её свойства. И заодно как раз говорится почему она на самом деле совершенна
      (но не идеальна). Но там вы вряд ли найдете что-то, чего я не отразил здесь.</p>
      <p
      style="margin-left:0px;">Оригинальная статья от Блэкли очень здорово описывает то, для чего всё
        это может пригодится и что вообще хочется построить, но дальше он отправляется
        в заумные дебри аналитической геометрии и всё становится плохо. К тому
        же, статья не использует удобные определения идеальной и совершенной схемы,
        потому что их тогда ещё не было. А ещё там описывается несколько более
        сложная (технически и для понимания) реализация схемы, нежели чем на англовики.</p>
        <p
        style="margin-left:0px;"><strong>Забавный факт:</strong> Привожу цитату о том, как Блэкли считает
          схему с многочленами несостоятельной. Менее чем через полгода выйдет статья
          Шамира, которая определит основную схему на многие годы вперед.</p>
          <blockquote>
            <p>For example, a polynomial of degree&nbsp;<span class="math-tex">\(b\)</span>&nbsp;can
              be reconstructed from its values at&nbsp;<span class="math-tex">\(b+1\)</span>&nbsp;points.
              But already its values at any&nbsp;<span class="math-tex">\(b\)</span>&nbsp;points
              tell a lot about it. It can also be reconstructed from the values of its&nbsp;
              <span
              class="math-tex">\(0\)</span>th through&nbsp;<span class="math-tex">\(0\)</span>th Taylor
                coefficients at a point. But already the values of any&nbsp;<span class="math-tex">\(b\)</span>&nbsp;of
                these&nbsp;<span class="math-tex">\(b+1\)</span>&nbsp;numbers tell a lot
                about it.</p>
          </blockquote>
          <h2>Введение или зачем нам это</h2>
          <p>Блэкли был первым, кто предложил разделение секрета, и потому подробно
            описал для чего такое может понадобиться.</p>
          <p>Пусть есть какой-то ценный секрет — приватный ключ для подписи всех документов,
            например. Существует немало крупных компаний, чей бизнес строится на буквально
            одном ключе и крепкой репутации (см. SSL или trusted timestamp). Итак,
            вот они хотят этот ключ надёжно сберечь. Но с любыми данными могут происходить
            инциденты.</p>
          <ol>
            <li>Порча информации. Либо человека сбила машина, либо он испачкал бумажку
              и случайно прочитал не то число.</li>
            <li>Предательство. Сотрудник сходил к конкурентам и рассказал им всё что только
              знал.</li>
            <li>Запросто может произойти и то, и другое — человек с грохотом сбежал к
              конкурентам и напрочь отказывается возвращать ценную информацию. Или они
              ему посоветовали соврать когда спросят.</li>
          </ol>
          <p>Таким образом, в целом, мы не можем с полной уверенностью сказать, был
            ли кусочек утерян (чтобы перевыпустить) или же раскрыт (чтобы заменить).
            Незнание правильности кусочков ещё повлияет при восстановлении секрета.</p>
          <p>Итак, за продолжительное время с данными обязательно что-то случится,
            этого не избежать. К счастью, крайне маловероятно, что это произойдёт со <strong>всеми</strong> данными,
            по крайней мере один кусочек должен сохранится.</p>
          <p>Что же. Будем считать, что мы разделили секрет на&nbsp;<span class="math-tex">\(n\)</span>&nbsp;кусочков
            и у нас произойдёт не больше&nbsp;<span class="math-tex">\(a\)</span>&nbsp;потерь
            и&nbsp;<span class="math-tex">\(b\)</span>&nbsp;предательств. Тогда, с
            одной стороны,&nbsp;<span class="math-tex">\(b\)</span>&nbsp;кусочков никак
            не должно быть достаточно для получения секрета (те, кто убежал к конкурентам).
            С другой же, всего у нас имеется&nbsp;<span class="math-tex">\(n - a\)</span>&nbsp;кусочков,
            по котором должно быть возможно восстановить данные. Т.е.&nbsp;<span class="math-tex">\(0 ≤ b &lt; n-a ≤ n\)</span>.
            Отсюда сразу становится понятно, что&nbsp;<span class="math-tex">\(n &gt; a + b\)</span>,
            т.е. хотя бы один кусочек не должен пострадать.</p>
          <p><strong>Метафора с ключами:</strong>
            <br>Пусть мы светим на ключ с разных сторон и получаем разные тени от зубчиков.
            После чего раздаём фотографии этих теней людям. Хочется сделать так, чтобы
            по&nbsp;<span class="math-tex">\(b+1\)</span>&nbsp;тени можно было восстановить
            полную форму ключа, а по любым&nbsp;<span class="math-tex">\(b\)</span>&nbsp;из
            них создавалось ощущение, что такие тени мог дать совершенно любой ключ
            из связки.</p>
          <p>Это очевидно защищает от раскрытия секретов: любые&nbsp;<span class="math-tex">\(b\)</span>&nbsp;кусочков
            не могут раскрыть весь секрет. Также есть защита и от утери, поскольку&nbsp;
            <span
            class="math-tex">\(b+1 ≥ n-a\)</span>. С защитой от порчи, когда участники схемы говорят
              неправильные значения, ситуация сложнее. Когда мы разделили секрет на&nbsp;
              <span
              class="math-tex">\(n\)</span>&nbsp;кусочков, то есть&nbsp;<span class="math-tex">\(C_n^{b+1}\)</span>&nbsp;способов
                попытаться восстановить истинный, причём гарантированно&nbsp;<span class="math-tex">\(C_{n-a}^{b+1}\)</span>&nbsp;из
                них дадут правильный ответ. Это достаточно много, учитывая что скорее всего
                «ложные» секреты вряд ли будут совпадать, и тогда можно будет найти настоящий.
                Конечно, это не даёт строгой гарантии восстановления, и мы не планируем
                обращать на эту деталь много внимания, но иногда будем вспоминать.</p>
          <h2>Схема Блэкли</h2>
          <p>Как я говорил, математическая реализация схемы требует использования многомерной
            геометрии, поэтому ограничимся только идеей. Всё равно эта схема не самая
            лучшая и почти всегда более простая схема Шамира оказывается лучше.</p>
          <figure
          class="image">
            <img src="%D0%A1%D1%85%D0%B5%D0%BC%D0%B0%20%D0%91%D0%BB%D1%8D%D0%BA%D0%BB%D0%B8/image.png">
            </figure>
            <p>Идея заключается в том, что&nbsp;<span class="math-tex">\(k\)</span>&nbsp;гиперплоскостей
              (размерности&nbsp;<span class="math-tex">\(k-1\)</span>) в&nbsp;<span class="math-tex">\(k\)</span>-мерном
              пространстве пересекаются ровно в одной точке. Вот эта точка и будет содержать
              секрет, а плоскости будут частями секрета. Очевидно, что через одну точку
              можно провести очень много плоскостей, следовательно можно разделить один
              секрет на большое число плоскостей (больше чем&nbsp;<span class="math-tex">\(k\)</span>).</p>
            <figure
            class="image">
              <img src="%D0%A1%D1%85%D0%B5%D0%BC%D0%B0%20%D0%91%D0%BB%D1%8D%D0%BA%D0%BB%D0%B8/1_image.png">
              </figure>
              <p>Схема такова:</p>
              <ol>
                <li>Выбирается достаточно большое многомерное дискретное пространство размерности&nbsp;
                  <span
                  class="math-tex">\(k\)</span>.</li>
                <li>Генерируется точка с координатами&nbsp;<span class="math-tex">\((s, z_2, z_3, …, z_k)\)</span>,
                  где&nbsp;<span class="math-tex">\(z_i\)</span>&nbsp;случайны. Тут важно,
                  что точка содержит секрет только в одной своей координате.</li>
                <li>Через эту точку проводится&nbsp;<span class="math-tex">\(n\)</span>&nbsp;случайных
                  (и различных) гиперплоскостей размерности&nbsp;<span class="math-tex">\(k-1\)</span>,
                  которые раздаются участникам схемы.</li>
              </ol>
              <p>Восстановление происходит просто поиском единственной точки их пересечения.</p>
              <p>Теперь проанализируем совершенность и идеальность этой схемы.</p>
              <h2>Совершенность</h2>
              <p>или почему никакой информации о секрете мы не получаем.</p>
              <p>Итак, пусть у нас есть&nbsp;<span class="math-tex">\(k-1\)</span>&nbsp;плоскость.
                Можем их пересечь и получить некоторую прямую, на которой точно лежит секрет.
                С одной стороны, кажется, что перебирать точек на прямой гораздо меньше,
                чем во всём пространстве целиком. На самом же деле, если схема реализована
                таким образом что секрет хранится ровно в одной координате точки, то мы
                не получаем никакой дополнительной информации. Это можно показать несколькими
                способами.</p>
              <ol>
                <li>Прямая — одномерное пространство. На ровно столько же точек, какова и
                  мощность множества значений одной координаты. А это как раз получается
                  множество значений секрета.</li>
                <li>Поскольку нас интересует только первая координата всех точек, то с тем
                  же успехом можно рассматривать проекцию прямой на соответствующую ось координат.
                  Если прямая не перпендикулярна этой оси, то её проекция займет все точки
                  на ней. <span style="background-color:hsl(30,75%,60%);">TODO: рисунок</span>
                </li>
                <li>Точка лежит на прямой тогда и только тогда, когда её координаты соответствуют
                  некоторому отношению. Зная это отношение, мы можем что-то утверждать про
                  все координаты точки вместе, но при этом на самом деле не можем ничего
                  сказать про каждую отдельную.</li>
              </ol>
              <h2>Идеальность</h2>
              <p>или как там с размером кусочка</p>
              <p>Плоскость задаётся уравнением плоскости:&nbsp;<span class="math-tex">\(x + \frac{B}{A}y + \frac{C}{A}z + … + \frac{D}{A}\)</span>.
                Здесь&nbsp;<span class="math-tex">\(k\)</span>&nbsp;параметров, как раз
                совпадает с размерностью пространства. Каждый из этих параметров берётся
                из того же поля, над которым построено пространство — одновременно и из
                того. из которого берется координата с секретом. Таким образом получаем,
                что каждый кусочек содержит в&nbsp;<span class="math-tex">\(k\)</span>&nbsp;раз
                больше информации, чем сам секрет. Таким образом схема <strong>неидеальна</strong>.</p>
              <p>Интересный факт, что можно закодировать секрет используя все координаты
                точки. В таком случае и точка, и плоскость содержат одинаковое количество
                информации, и схема идеальна. Но как показано ранее, в таком случае схема
                перестаёт быть совершенной. Если мы не обладаем никакой информацией, то
                каждая из точек пространства содержит различный секрет с равной вероятностью.
                Если же мы знаем хотя бы одну плоскость, то уже можем с уверенностью говорить,
                что точка лежит на ней, что в&nbsp;<span class="math-tex">\(|S|\)</span>&nbsp;раз
                снижает количество возможных вариантов.</p>
              <p><strong>Однако!</strong> При помощи очень смелого хода можно сделать схему
                одновременно и идеальной, и совершенной. <span style="background-color:hsl(30,75%,60%);">TODO: </span>Brickell,
                E. F. (1989, April). Some ideal secret sharing schemes. In Workshop on
                the Theory and Application of of Cryptographic Techniques (pp. 468-475).
                Springer, Berlin, Heidelberg.</p>
              <figure class="image">
                <img src="%D0%A1%D1%85%D0%B5%D0%BC%D0%B0%20%D0%91%D0%BB%D1%8D%D0%BA%D0%BB%D0%B8/2_image.png">
              </figure>
              <p>&nbsp;</p>
              <h2>Реализация</h2>
              <p>Чтобы реализовать схему совершенно, необходимо чтобы никакая из прямых
                пересечения не была перпендикулярна оси координат, содержащей секрет. Вообще-то
                говоря, нужно проверить&nbsp;<span class="math-tex">\(C_n^k\)</span>&nbsp;комбинаций
                плоскостей, что весьма немало. С другой стороны, вероятность этого довольно
                мала и падает с ростом размерности.</p>
              <p>Теперь пара слов о том, как собственно говоря искать пересечение между
                плоскостями. Надо всего лишь решить следующую СЛАУ (<span class="math-tex">\(A…Z\)</span>&nbsp;—
                кусочки секрета, их&nbsp;<span class="math-tex">\(k\)</span>&nbsp;штук)</p>
              <span
              class="math-tex">\[\begin{cases}A_1 + x_1 + A_2x_2 + A_3x_3 + … + A_jkx_k = 0\\…\\Z_1 +
                x_1 + Z_2x_2 + Z_3x_3 + … + Z_kx_k = 0\end{cases}\]</span>
                <p>Она содержит&nbsp;<span class="math-tex">\(k\)</span>&nbsp;переменных
                  и&nbsp;<span class="math-tex">\(k\)</span>&nbsp;уравнений. Поскольку нам
                  требуется найти только одну из переменных, удобно воспользоваться формулами
                  Крамера, которые это позволяют сделать относительно быстро.</p>
  </body>

</html>