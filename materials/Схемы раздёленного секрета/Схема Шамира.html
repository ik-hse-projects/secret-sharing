<!doctype html>
<html>
  
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="../style.css">
    
<link href="https://rawcdn.githack.com/iliakonnov/linlibertine/718d3ae934bec3bb1cb173af93ad22a42362c266/linlibertine.css" rel="stylesheet"> 
<style>body { font-family: "Linux Libertine", serif; }</style> 
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.css" integrity="sha384-zTROYFVGOfTw7JV7KUu8udsvW2fx4lWOsCEDqhBreBwlHI4ioVRtmIvEThzJHGET" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.js" integrity="sha384-GxNFqL3r9uRJQhR+47eDxuPoNE7yLftQM8LcxzgS4HT73tp970WS/wV5p8UzCOmb" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/contrib/auto-render.min.js" integrity="sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl" crossorigin="anonymous" onload="renderMathInElement(document.body);"></script>

  </head>
  
  <body class="ck-content">
     <h1>Схема Шамира</h1>

    <p>Хотим разделить секрет&nbsp;<span class="math-tex">\(S\)</span>&nbsp;между&nbsp;
      <span
      class="math-tex">\(n\)</span>&nbsp;участниками так, чтобы любые&nbsp;<span class="math-tex">\(k\)</span>&nbsp;могли
        его восстановить. Как?</p>
    <ul>
      <li><a href="https://en.wikipedia.org/wiki/Shamir's_Secret_Sharing">https://en.wikipedia.org/wiki/Shamir's_Secret_Sharing</a>
      </li>
    </ul>
    <p>Придумана в 1979 году.</p>
    <h2>Распределение секрета</h2>
    <p>Построим над произвольным полем многочлен степени&nbsp;<span class="math-tex">\(k-1\)</span>:</p>
    <span
    class="math-tex">\[f(x) = S + a_1x + a_2x^2 + … + a_{k-1}x^{k-1}\]</span>
      <p>Таким образом, секрет зашифрован в этом многочлене:&nbsp;<span class="math-tex">\(S = f(0)\)</span>.
        <br>Здесь&nbsp;<span class="math-tex">\(a_i\)</span>&nbsp;— случайные числа,
        которые никому не сообщаются и более не понадобятся.</p>
      <p>Затем выберем&nbsp;<span class="math-tex">\(n\)</span>&nbsp;произвольных
        различных точек (<span class="math-tex">\(x_i≠0\)</span>). Это будут проекции
        секрета:</p><span class="math-tex">\[A_1 = (x_1, f(x_1))\\A_2 = (x_2, f(x_2))\\⋮\\A_n=(x_n, f(x_n))\]</span>
      <p>Таким образом каждый участник знает точные координаты одной некоторой
        точки на многочлене.</p>
      <h2>Восстановление секрета</h2>
      <p>Пусть&nbsp;<span class="math-tex">\(k\)</span>&nbsp;участников желают
        восстановить секрет обратно. Нам известны координаты&nbsp;<span class="math-tex">\(k\)</span>&nbsp;точек
        некоторого многочлена степени&nbsp;<span class="math-tex">\(k-1\)</span>,
        и хотим полностью восстановить его. Как известно, это возможно, причём <strong>единственным образом</strong>.
        Например, при помощи&nbsp;<a class="reference-link" href="%D0%A1%D1%85%D0%B5%D0%BC%D0%B0%20%D0%A8%D0%B0%D0%BC%D0%B8%D1%80%D0%B0/%D0%98%D0%BD%D1%82%D0%B5%D1%80%D0%BF%D0%BE%D0%BB%D1%8F%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D1%8B%D0%B9%20%D0%BC%D0%BD%D0%BE%D0%B3%D0%BE%D1%87%D0%BB%D0%B5%D0%BD%20%D0%9B%D0%B0%D0%B3.html"
        data-note-path="root/2C0iPZniLb0e/64kEKvAm2lE0/t1AQNAJiCPWU/9Bu5ok3TZrPt">Интерполяционный многочлен Лагранжа</a>.</p>
      <p>Однако стоит использовать тот факт, что требуется лишь вычислить значение
        многочлена в точке&nbsp;<span class="math-tex">\(x=0\)</span>&nbsp;и значительно
        облегчить вычисления:</p><span class="math-tex">\[f(0) = \sum_{j=0}^{k-1} f(x_j) \prod_{\substack{m=0\\m≠j}}^{k-1}\frac{x_m}{x_m-x_j}\]</span>
      <h2>Почему&nbsp;<span class="math-tex">\(x_0=0\)</span></h2>
      <p>Нет ничего особенного именно в этой точке, просто так многочлен имеет
        красивый вид&nbsp;<span class="math-tex">\(f(x) = … + s\)</span>, а если
        же&nbsp;<span class="math-tex">\(x_0 ≠0\)</span>, то необходимо сделать
        дополнительные вычисления, т.к. свободный член должен быть равен&nbsp;
        <span
        class="math-tex">\(s - f_0(x_0)\)</span>, где&nbsp;<span class="math-tex">\(f_0\)</span>&nbsp;—
          многочлен с нулевым свободным членом.</p>
      <h2>Преимущества</h2>
      <p>Схема позволяет свободно добавлять новых участников (увеличивать&nbsp;
        <span
        class="math-tex">\(n\)</span>, но не&nbsp;<span class="math-tex">\(k\)</span>), вплоть
          до исчерпания всех элементов поля.</p>
      <p>Интересная особенность заключается в том, что она не построена на какой-то
        практически неразрешимой проблемой, о которой ничего не доказано (дискретное
        логарифмирование), в отличии от обычного шифрования.</p>
      <h2>Идеальность</h2>
      <p>Точка содержит столько же бит данных, сколько и сам секрет. Связано с
        тем, что координаты&nbsp;<span class="math-tex">\(x\)</span>&nbsp;являются
        публичными и не учитываются, а секретная координата&nbsp;<span class="math-tex">\(y\)</span>&nbsp;берётся
        из того же поля, что и&nbsp;<span class="math-tex">\(s\)</span>, т.к. это
        всё — значения многочлена.</p>
      <p>Строго говоря, для этого секрет должен выбираться из того же множества,
        над которым строится многочлен, что не всегда так, поскольку многочлен
        обычно строится над множеством&nbsp;<span class="math-tex">\(ℤ_p\)</span>,
        где&nbsp;<span class="math-tex">\(p\)</span>&nbsp;— простое. <span style="background-color:hsl(30,75%,60%);">TODO: китайская теорема об остатках</span>
      </p>
      <h2>(Не)Совершенность</h2>
      <p><strong>В теории</strong>, эта схема идеальна — знание даже&nbsp;
        <span
        class="math-tex">\(k-1\)</span>&nbsp;точек не позволяет получить совершенно никакой информации
          о секрете.</p>
      <p>Это связано с тем, что всегда можно построить многочлен, проходящий через
        все&nbsp;<span class="math-tex">\(k-1\)</span>&nbsp;известных точек и одновременно
        через точку&nbsp;<span class="math-tex">\((0, y)\)</span>, где&nbsp;
        <span
        class="math-tex">\(y\)</span>&nbsp;— произвольное число. Таким образом, никакой полезной
          информации о секрете получено не было — количество возможных вариантов
          секрета равно мощности поля.</p>
      <p><strong>Однако!</strong> Это работает только тогда, когда многочлен строится
        в бесконечном поле. Например, если дополнительно известно, что все коэффициенты
        многочлена принадлежат&nbsp;<span class="math-tex">\(ℤ_5\)</span>, то при
        известных двух точках далеко не через каждую оставшуюся возможно построить
        многочлен.</p>
      <h3>Пример атаки</h3>
      <p>Очень важен выбор поля. Например, посмотрим что будет, если были выбраны
        простые натуральные числа. То есть все коэффициенты многочлена неотрицательные.
        <br>Пусть нам известны две точки:&nbsp;<span class="math-tex">\((1, 1494), (2, 1942)\)</span>&nbsp;и
        известно, что многочлен квадратный:&nbsp;<span class="math-tex">\(f(x) = S + a_1x + a_2x^2\)</span>.
        Подставим и преобразуем:</p><span class="math-tex">\[\begin{cases}f(1) = S + a_1 + a_2 = 1494\\f(2)=S+2a_1+4a_2 = 1942\end{cases}\]</span>
      <span
      class="math-tex">\[f(2)-f(1) = a_1 + 3a_2 = 448\]</span><span class="math-tex">\[\begin{cases}a_1 = 448 - 3a_2\\S = 1494 - a_2 - a_1 &nbsp;= 1046 + 2a_2\end{cases}\]</span>
        <p>Поскольку нам известно, что&nbsp;<span class="math-tex">\(a_1 ≥ 0\)</span>,
          то можем сказать, что&nbsp;<span class="math-tex">\(0 ≤ a_2 &lt; \frac{448}{3}\)</span>.
          Отсюда получаем ограничение на секрет:&nbsp;<span class="math-tex">\(1046 ≤ S &lt; 1344\)</span>
        </p>
        <p>Таким образом остается перебрать лишь&nbsp;<span class="math-tex">\(≈150\)</span>&nbsp;значений
          вместо всех натуральных чисел.</p>
        <h3>Защита от атаки</h3>
        <p>Вполне достаточно будет использовать <strong>конечное</strong> поле мощности&nbsp;
          <span
          class="math-tex">\(p: p&gt;S, p&gt;n\)</span>. То есть всего лишь при выборе поля вычетов
            нужно взять достаточно большое простое число.</p>
        <p>Теперь, строго говоря,&nbsp;<span class="math-tex">\(f(x) = (f(x) \mod p) + m_1p\)</span>.
          Скорректируем пример:</p><span class="math-tex">\[f(2) - f(1) = a_1 + 3a_2 + (m_1 - m_2)p\\⇒ a_1 = 448 - 3a_2 - (m_1 - m_2)p\]</span>
        <p>Отсюда мы не можем наложить никакого ограничения на&nbsp;<span class="math-tex">\(a_1\)</span>,
          а значит и сократить количество возможных вариантов секрета.</p>
        <p>Если говорить более строго, то сгодится совершенно любое <strong>поле</strong>,
          чтобы для любого множества точек существовал подходящий многочлен, через
          них проходящий.&nbsp;<span class="math-tex">\(ℕ\)</span>&nbsp;не является
          полем! В практической реализации также важно использовать весь доступный
          диапазон значений, иначе атакующий может опять-таки предположить что значения
          лежат в некотором множестве, не являющимся полем, и в нём не через всякие
          точки возможно провести многочлен. Просто замена <code>uint</code> на <code>int</code> в
          вычислениях не решит проблему, надо действительно использовать весь диапазон.</p>
  </body>

</html>