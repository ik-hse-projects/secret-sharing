<!doctype html>
<html>
  
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="../style.css">
    
<link href="https://rawcdn.githack.com/iliakonnov/linlibertine/718d3ae934bec3bb1cb173af93ad22a42362c266/linlibertine.css" rel="stylesheet"> 
<style>body { font-family: "Linux Libertine", serif; }</style> 
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.css" integrity="sha384-zTROYFVGOfTw7JV7KUu8udsvW2fx4lWOsCEDqhBreBwlHI4ioVRtmIvEThzJHGET" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.js" integrity="sha384-GxNFqL3r9uRJQhR+47eDxuPoNE7yLftQM8LcxzgS4HT73tp970WS/wV5p8UzCOmb" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/contrib/auto-render.min.js" integrity="sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl" crossorigin="anonymous" onload="renderMathInElement(document.body);"></script>

  </head>
  
  <body class="ck-content">
     <h1>On secret sharing systems</h1>

    <ul>
      <li><a href="https://ru.wikipedia.org/wiki/Схема_Карнина_—_Грина_—_Хеллмана">https://ru.wikipedia.org/wiki/Схема_Карнина_—_Грина_—_Хеллмана</a>
      </li>
      <li>E. Karnin, J. Greene and M. Hellman, "<a href="https://ieeexplore-ieee-org.proxylibrary.hse.ru/abstract/document/1056621">On secret sharing systems</a>,"
        in IEEE Transactions on Information Theory, vol. 29, no. 1, pp. 35-41,
        January 1983, doi: 10.1109/TIT.1983.1056621.</li>
    </ul>
    <h2>Теорема 1</h2>
    <p>Пусть выбраны&nbsp;<span class="math-tex">\(s∈S\)</span>&nbsp;и&nbsp;
      <span
      class="math-tex">\(v_1,…,v_n∈V\)</span>. Тогда хотим чтобы выполнялось следующее:</p>
    <ol>
      <li><span class="math-tex">\(\mathrm{H}(s \mid v_{i_1}, …, v_{i_k}) = 0\)</span>&nbsp;—
        зная любые&nbsp;<span class="math-tex">\(k\)</span>&nbsp;кусочков можно
        достоверно извлечь секрет.</li>
      <li><span class="math-tex">\(\mathrm{H}(s \mid v_{i_1}, …, v_{i_{k-1}}) = \mathrm{H}(s)\)</span>&nbsp;—
        но если даже одного кусочка не хватает, то никаких дополнительных предположений
        о&nbsp;<span class="math-tex">\(s\)</span>&nbsp;сделать невозможно.</li>
    </ol>
    <p>Тогда теорема гласит, что&nbsp;<span class="math-tex">\(\mathrm{H}(v_i)≥\mathrm{H}(s)\)</span>
    </p>
    <p>Следствия:</p>
    <ol>
      <li>Если&nbsp;<span class="math-tex">\(s∈S\)</span>&nbsp;выбрано случайно,
        то следует что&nbsp;<span class="math-tex">\(|V|≥|S|\)</span>, т.е. что
        каждый кусочек не может быть меньше самого ключа.</li>
      <li>Если схема идеальная (<span class="math-tex">\(|V| ≤ |S|\)</span>), то
        можно говорить что&nbsp;<span class="math-tex">\(|V| = |S|\)</span>. Т.е.
        что каждый кусочек равен по размеру самому ключу.</li>
    </ol>
    <h3>Доказательство</h3>
    <p>Имеется такое отношение:&nbsp;<span class="math-tex">\(\mathrm{H}(v_{i_k}) ≥ \mathrm{I}(s; v_{i_k}\mid v_{i_1},…,v_{i_{k-1}})\)</span>,
      поскольку случайное значение не может предоставить больше информации чем
      в нём есть неопределённости. <span style="background-color:hsl(30,75%,60%);">TODO!</span>
    </p>
    <p>Используя предпосылки теоремы, также получаем, что&nbsp;<span class="math-tex">\(\mathrm{I}(s; v_{i_k}\mid v_{i_1},…,v_{i_{k-1}}) = \mathrm{H}(s)\)</span>.</p>
    <p>Отсюда получаем, что&nbsp;<span class="math-tex">\(\mathrm{H}(v_{i_k}) ≥ \mathrm{H}(s)\)</span>,
      ч.т.д.</p>
    <h2>Обзор</h2>
    <p><a href="%D0%A1%D1%85%D0%B5%D0%BC%D0%B0%20%D0%A8%D0%B0%D0%BC%D0%B8%D1%80%D0%B0.html">Схема Шамира</a> не
      очень хороша, сравнивая со со схемой Блекли, потому что для совершенности
      схемы необходимо использовать конечное поле&nbsp;<span class="math-tex">\(F : |F| = |S|\)</span>,
      но это означает что существует только&nbsp;<span class="math-tex">\(|F|\)</span>&nbsp;различных
      точек, а значит нельзя неограниченно увеличивать&nbsp;<span class="math-tex">\(n: n ≤ |F| - 1\)</span>&nbsp;(кроме
      случая&nbsp;<span class="math-tex">\(k=1\)</span>, когда каждый участник
      знает секрет).</p>
    <p>Эту схему можно рассматривать как детерминистическую версию схема Блекли,
      которая влючает схему Шамира в качестве специального случая. Рассказывается
      в части Ⅱ.</p>
    <p>В части Ⅲ для всякой СРС (линейной и нет) устанавливаются границы на максимальное
      значение&nbsp;<span class="math-tex">\(n\)</span>&nbsp;для заданных&nbsp;
      <span
      class="math-tex">\(k, |S|\)</span>.</p>
    <p>В части Ⅳ схемы обобщаются. Пусть нужно защищать&nbsp;<span class="math-tex">\(l\)</span>&nbsp;секретов&nbsp;
      <span
      class="math-tex">\(s_1, …, s_l\)</span>, так чтобы каждый мог быть аналогично восстановлен
        при помощи любых&nbsp;<span class="math-tex">\(k\)</span>&nbsp;кусочков.
        Важно заметить, что зная некоторые кусочки нельзя получить информации ни
        об одном кокретном секрете, но можно что-то узнать о двух (или больше)
        секретах как паре. Таким образом можно защищать бо́льшие секреты используя
        то же количество информации в кусочках.</p>
    <p>А о частях Ⅴ и Ⅵ я рассказывать не буду, поля этого конспекта слишком
      узки.</p>
    <h2>Сама схема</h2>
    <p>Возьмём совершенно случайный&nbsp;<span class="math-tex">\(u\)</span>&nbsp;—
      вектор из 300 битов. Построим&nbsp;<span class="math-tex">\(v_i\)</span>:</p>
    <ol>
      <li>Выбираем произвольную выборку 100 битов из&nbsp;<span class="math-tex">\(u\)</span>.</li>
      <li>Посчитаем исключающее или выбранных битов (бит чётности).</li>
      <li>Поместим получившийся бит в&nbsp;<span class="math-tex">\(v_i\)</span>
      </li>
      <li>Повторять процедуру 100 раз, чтобы в&nbsp;<span class="math-tex">\(v_i\)</span>&nbsp;состоял
        из 100 битов чётности.</li>
    </ol>
    <p>Известны следующие факты о матрицах над полем&nbsp;<span class="math-tex">\(ℤ_2\)</span>&nbsp;(битовых):</p>
    <ol>
      <li>Примерно 29% матриц&nbsp;<span class="math-tex">\(n×n\)</span>&nbsp;невырожденные
        (их ранг равен&nbsp;<span class="math-tex">\(n\)</span>).</li>
      <li>У большинства оставшихся ранг матрицы почти совпадает с её размером.</li>
    </ol>
    <p>Отсюда получаем, что с большой вероятностью по любым трём&nbsp;<span class="math-tex">\(v_i\)</span>&nbsp;удастся
      восстановить&nbsp;<span class="math-tex">\(u\)</span>&nbsp;целиком.</p>
    <p><span style="background-color:hsl(30,75%,60%);">TODO</span>
    </p>
    <p>&nbsp;</p>
    <p>&nbsp;</p>
    <p>&nbsp;</p>
    <p>&nbsp;</p>
    <p>&nbsp;</p>
    <p>&nbsp;</p>
  </body>

</html>