<!doctype html>
<html>
  
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="../../style.css">
    
<link href="https://rawcdn.githack.com/iliakonnov/linlibertine/718d3ae934bec3bb1cb173af93ad22a42362c266/linlibertine.css" rel="stylesheet"> 
<style>body { font-family: "Linux Libertine", serif; }</style> 
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.css" integrity="sha384-zTROYFVGOfTw7JV7KUu8udsvW2fx4lWOsCEDqhBreBwlHI4ioVRtmIvEThzJHGET" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.js" integrity="sha384-GxNFqL3r9uRJQhR+47eDxuPoNE7yLftQM8LcxzgS4HT73tp970WS/wV5p8UzCOmb" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/contrib/auto-render.min.js" integrity="sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl" crossorigin="anonymous" onload="renderMathInElement(document.body);"></script>

  </head>
  
  <body class="ck-content">
     <h1>Мошенники</h1>

    <p>Разделение секрета используется тогда, когда участникам нету полного доверия.
      Допустим, что некоторые из них (<span class="math-tex">\(m\)</span>&nbsp;штук)
      — злоумышленники. Они сговорились и хотят альтернативные кусочки&nbsp;
      <span
      class="math-tex">\(v'_1,v'_2,…,v'_m\)</span>, такие чтобы после расшифровки секрета&nbsp;
        <span
        class="math-tex">\(s\)</span>, тот выглядел как настоящий (<span class="math-tex">\(s'∈S\)</span>),
          но таковым не являлся (<span class="math-tex">\(s'≠s\)</span>). Как от
          этого защититься?</p>
    <ul>
      <li>Tompa, Martin, and Heather Woll. "<a href="https://link.springer.com/content/pdf/10.1007/BF02252871.pdf">How to share a secret with cheaters.</a>"
        journal of Cryptology 1.3 (1989): 133-138.</li>
    </ul>
    <h2>А зачем?</h2>
    <p>Допустим, вы возглавляете подпольное сопротивление. Отправляясь на некоторое
      задание в стан врага, вы распределяете номер своего банковского счета между
      своими сообщниками. Они должны будут строго по вашему сигналу перевести
      вам деньги, ведь почти сразу после этого вас раскроют. Собственно, именно
      ради этого и придумано разделение секрета. Но вот атакующий незаметно для
      остальных подменяет секрет и все деньги уходят непонятно куда. Таким образом:
      ваша организация осталась без денег, миссия сорвана, шпион остался незамеченным.
      Сообщники могли бы предпринять что-то, если бы узнали о провале. Но они
      этого не узнали пока не стало слишком поздно…</p>
    <p>Также атака может предсказуемо влиять на восстановленный секрет. Поскольку
      атакующий знает о факте атаки и знает как она меняет секрет, то он единственный
      сможет восстановить истинное значение секрета. В то время как все остальные
      неожиданно для себя получат несколько искаженное значение.</p>
    <p>Пример: вы с другом обратились к брокеру, чтобы честно сохранить свои
      биткоины. В итоге получили схему, в которой только вы оба одновременно
      можете знать приватный ключ, но не по одиночке. Ваш друг проводит атаку
      и делает так, что вы получаете некорректный ключ. Пока пытаетесь понять
      что пошло не так, бывший друг уже перевёл все монеты себе.</p>
    <h2>Атака на схему Шамира</h2>
    <p>Для проведения атаки достаточно даже одного недобросовестного участника.</p>
    <p>Пусть&nbsp;<span class="math-tex">\(x_1,x_2,…,x_k\)</span>&nbsp;— аргументы
      сгенерированных точек многочлена, причём злоумышленник обладает первой
      точкой&nbsp;<span class="math-tex">\(x_1\)</span>. Ему необходимо построить
      следующий многочлен&nbsp;<span class="math-tex">\(g(0) = -1, g(x_2) = 0, …, g(x_k)=0\)</span>&nbsp;степени
      не больше&nbsp;<span class="math-tex">\(k-1\)</span>. После этого он озвучивает
      остальным кусочек&nbsp;<span class="math-tex">\(v_1' = v_1 + g(x_1)\)</span>.
      Теорема об интерполяции в таком случае гарантирует, что восстановленный
      секрет&nbsp;<span class="math-tex">\(s'\)</span>&nbsp;будет равен&nbsp;
      <span
      class="math-tex">\(s-1\)</span>. Скорее всего&nbsp;<span class="math-tex">\(s'∈S\)</span>,
        если только не&nbsp;<span class="math-tex">\(s = 0\)</span>&nbsp;(маловероятно).
        Та-да! Атака прошла незамеченной, удалось испортить секрет.</p>
    <p>Пример:
      <br><span class="math-tex">\(f(x) = x^2 - 8x + 5\)</span>&nbsp;проходит через
      точки&nbsp;<span class="math-tex">\((0, 5), (1, -2), (5, -10), (6, -7)\)</span>.
      Допустим, что первый участник хочет изменить секрет на&nbsp;<span class="math-tex">\(-1\)</span>.
      Тогда он интерполирует многочлен через&nbsp;<span class="math-tex">\((0, -1), (5, 0), (6, -7)\)</span>&nbsp;и
      получает&nbsp;<span class="math-tex">\(g(x) = -\frac{x^2}{30} + \frac{11x}{30} - 1\)</span>.
      Заметим, что&nbsp;<span class="math-tex">\(g(1) = \frac{-2}{3}\)</span>,
      следовательно атакующий должен назвать&nbsp;<span class="math-tex">\(v_1' = -2 - \frac{2}{3} = -\frac{8}{3}\)</span>.
      Теперь восстановим секрет с изменённой точкой: интерполируем через&nbsp;
      <span
      class="math-tex">\((1, -\frac{8}{3}), (5, -10), (6, -7)\)</span>&nbsp;и получаем&nbsp;
        <span
        class="math-tex">\(f'(x) = \frac{29}{30}x^2 - \frac{229}{30}x + 4\)</span>. На удивление,&nbsp;
          <span
          class="math-tex">\(f'(0) = 4 = s - 1\)</span>, как и хотелось.</p>
    <p>Хочется от этого защититься, причём желательно сохранить простоту схемы
      Шамира, и её красоту в плане доказанной надёжности (не использовать непонятно-насколько-сложные
      проблемы вроде дискретного логарифмирования).</p>
    <p>Желаемое свойство таково:
      <br>Если любые&nbsp;<span class="math-tex">\(k-1\)</span>&nbsp;участников
      захотят провести атаку на схему, то вероятность их успеха должна быть крайне
      мала (<span class="math-tex">\(ε&gt;0\)</span>).</p>
    <p>Вероятность не может быть равна нулю, потому что в таком случае это бы
      значило, что для&nbsp;<span class="math-tex">\(k-1\)</span>&nbsp;кусочков
      существует только один подходящий&nbsp;<span class="math-tex">\(s_k\)</span>,
      такой чтобы восстановленный секрет был корректен. Но это напрямую противоречит
      свойству, что знание&nbsp;<span class="math-tex">\(k-1\)</span>&nbsp;кусочков
      не даёт никакой информации о секрете.</p>
    <h2>Решение проблемы</h2>
    <p>Очевидный вариант — дилер своим приватным ключом подписывает все розданные
      кусочки. При восстановлении секрета все должны будут просто проверить подпись.
      Но есть минусы: это добавляет большую сложность ассиметрической криптографии
      в элегантную схему Шамира, и основывается на наверное-сложных-но-это-не-точно
      проблемах.</p>
    <p>Решение очень просто. В схеме Шамира будем выбирать&nbsp;<span class="math-tex">\(x_1,…,x_m\)</span>&nbsp;не
      предсказуемым общеизвестным способом, а случайно из всех возможных, и засекретим
      их. Таким образом секретный кусочек вместо&nbsp;<span class="math-tex">\(v_i = f(x_i)\)</span>&nbsp;становится&nbsp;
      <span
      class="math-tex">\(v_i = (x_i, f(x_i))\)</span>.</p>
    <p>Благодаря этому злоумышленник не может узнать, какие точки ему необходимо
      оставить неизменными. Вероятность же того, что&nbsp;они случайно угадают
      нужную точку&nbsp;<span class="math-tex">\(f(x_1) = f'(x_1)\)</span>&nbsp;не
      так уж и велика.</p>
    <p>Но что если&nbsp;<span class="math-tex">\(k-1\)</span>&nbsp;атакующих <strong>знают</strong> секретный
      многочлен и хотят коллективно обмануть последнего участника? Заставить
      его поверить, что секрет на самом деле равен&nbsp;<span class="math-tex">\(s'\)</span>.
      На самом деле, схема защищает и от этого тоже.</p>
    <h2>Полная реализация схемы</h2>
    <p>Хотим построить схему, в которой вероятность такой атаки будет меньше,
      чем некоторый&nbsp;<span class="math-tex">\(ε\)</span>.</p>
    <ol>
      <li>Нужно достаточно большое конечное поле. Будем использовать вычеты по простому
        модулю&nbsp;<span class="math-tex">\(p &gt; max\left(\frac{(|S|-1)(k-1)}{ε} + k, n\right)\)</span>.</li>
      <li>Выбираем случайные коэффициенты для многочлена.</li>
      <li>Выбираем случайно различные&nbsp;<span class="math-tex">\(x_1, …, x_n\)</span>&nbsp;из
        множества&nbsp;<span class="math-tex">\(\{1,…,p-1\}\)</span>. Т.е. из всего
        поля, кроме нуля, поскольку ноль уже занят под секрет.</li>
      <li>Раздаём пары&nbsp;<span class="math-tex">\((x_i, f(x_i))\)</span>&nbsp;участникам.</li>
    </ol>
    <p>Без потери общности считаем, что&nbsp;<span class="math-tex">\(x_1\)</span>&nbsp;не
      предавал, а обладатели&nbsp;<span class="math-tex">\(x_2, …, x_k\)</span>&nbsp;—
      злоумышленники.</p>
    <p>Теперь предположим, что&nbsp;<span class="math-tex">\(k-1\)</span>&nbsp;участников
      решили атаковать. Требуется оценить вероятность того, что полученный в
      таком случае многочлен одновременно не проходит через&nbsp;<span class="math-tex">\((0, s)\)</span>&nbsp;(ведь
      цель стоит обмануть) и успешно проходит через&nbsp;<span class="math-tex">\((x_1, f(x_1))\)</span>.
      Только в таком случае атака будет успешна.</p>
    <p><span style="background-color:hsl(30,75%,60%);">TODO</span>: Почему он
      может <strong>не</strong> проходить через&nbsp;<span class="math-tex">\((x_1, f(x_1))\)</span>,
      если при эта точка участвует в интерполяции?</p>
    <p>Итак, оценим вероятность того, что&nbsp;<span class="math-tex">\(f'(x_1) = f(x_1)\)</span>.
      Во-первых, предположим, что&nbsp;<span class="math-tex">\(f'(0) ≠ f(0)\)</span>.
      Поскольку эти многочлены оба имеют степень&nbsp;<span class="math-tex">\(k-1\)</span>,
      то они могут пересекаться друг с другом не более чем в&nbsp;<span class="math-tex">\(k-1\)</span>&nbsp;точке
      (иначе они будут совпадать). Во-вторых, оставшееся неизвестным значение&nbsp;
      <span
      class="math-tex">\(x_1\)</span>&nbsp;может принимать одно из значений множества&nbsp;
        <span
        class="math-tex">\(\{1, …, p-1\} \setminus \{x_2, …, x_k\}\)</span>, т.е. одно из&nbsp;
          <span
          class="math-tex">\((p-1) - (k-1) = p-k\)</span>&nbsp;значений. Отсюда получаем вероятность,
            что одна из точек пересечения также окажется в нужном месте:&nbsp;
            <span
            class="math-tex">\(\frac{k-1}{p-k}\)</span>
    </p>
    <p>Далее, добавим тот факт, что атакующим подходят все многочлены, не проходящие
      через&nbsp;<span class="math-tex">\((0, f(0))\)</span>. Таких многочленов
      существует&nbsp;<span class="math-tex">\(|S| - 1\)</span>&nbsp;штук — по
      одному на каждое корректное значение&nbsp;<span class="math-tex">\(s'\)</span>.</p>
    <p>Таким образом, получившаяся вероятность успешно проведённой атаки равна&nbsp;</p>
    <span
    class="math-tex">\[\frac{(|S| - 1)(k - 1)}{p-k} &lt; ε\]</span>
      <p>Еще один повод выбирать&nbsp;<span class="math-tex">\(p\)</span>&nbsp;побольше.</p>
      <h2>Заметили атаку, а что дальше?</h2>
      <p>При помощи такой схемы возможно только с высокой вероятностью обнаружить
        атаку, но не предотвратить последствия. Как уже говорилось, атакующие способны
        восстановить настоящее значение секрета, в то время как все добросовестные
        никакой информации почти никакой информации о нём не получают. Хочется
        чтобы атакующие не могли и этого.</p>
      <p><span style="background-color:hsl(30,75%,60%);">TODO</span>: А каким образом
        атакующие могут <strong>предсказуемо</strong> влиять на секрет, если они
        не знают совсем никакой информации о других точках по которым происходит
        интерполирование?</p>
      <p>Добавим в множество&nbsp;<span class="math-tex">\(S\)</span>&nbsp;специальное
        значение&nbsp;<span class="math-tex">\(d\)</span>, которое будет обозначать
        фиктивный (dummy) секрет. Оно никогда не используется для секрета настоящего.</p>
      <p>Дилер разделяет секрет&nbsp;<span class="math-tex">\(s\)</span>&nbsp;на
        части:&nbsp;<span class="math-tex">\(s_1, …, s_t\)</span>, где ровно одна
        случайная содержит секрет, а все остальные содержат фиктивное значение&nbsp;
        <span
        class="math-tex">\(d\)</span>.
          <br>То есть существует такое случайное&nbsp;<span class="math-tex">\(i\)</span>,
          что&nbsp;<span class="math-tex">\(s_j = \begin{cases}d,&amp;i ≠ j\\s,&amp; i=j\end{cases}\)</span>
      </p>
      <p>Затем дилер каждое значение&nbsp;<span class="math-tex">\(s_j\)</span>&nbsp;разделяет
        на части по уже известной схеме и раздаёт их участникам. Каждый получает&nbsp;
        <span
        class="math-tex">\(t\)</span>&nbsp;кусочков. На этом этапе никто не знает номер истинного&nbsp;
          <span
          class="math-tex">\(s_i\)</span>.</p>
      <p>Восстановление же секрета происходит по следующему алгоритму (начиная
        с&nbsp;<span class="math-tex">\(s_1\)</span>):</p>
      <ol>
        <li>Берём кусочки части&nbsp;<span class="math-tex">\(s_j\)</span>&nbsp;и
          восстанавливаем её</li>
        <li>Если&nbsp;<span class="math-tex">\(s_j ≠ d\)</span>, то мы получили настоящий
          секрет. Ура! Завершаем алгоритм.</li>
        <li>Если же&nbsp;<span class="math-tex">\(s_j = d\)</span>, то переходим к
          следующей части:&nbsp;<span class="math-tex">\(s_{j+1}\)</span>
        </li>
        <li>Если вдруг все части оказались фиктивными, то атакующие ужасно везучие
          и заменили секрет&nbsp;<span class="math-tex">\(s\)</span>&nbsp;на значение&nbsp;
          <span
          class="math-tex">\(d\)</span>.</li>
      </ol>
      <p>Итак, теперь рассмотрим действия атакующих в такой схеме. Они могут сообщить
        ложные кусочки при восстановлении любого из&nbsp;<span class="math-tex">\(s_j\)</span>.
        Проблема в том, что они не знают какое из них содержит сам секрет. Если
        они не угадают и атакуют&nbsp;<span class="math-tex">\(s_j = d\)</span>,
        то, во-первых, алгоритм (скорее всего) завершится, поскольку расшифрованное
        значение не будет равно&nbsp;<span class="math-tex">\(d\)</span>&nbsp;—
        цель атакующих заключается в том, чтобы изменить восстановленное значение.
        Во-вторых, атакующие не получат никакой полезной информации о секрете,
        поскольку значение&nbsp;<span class="math-tex">\(d\)</span>&nbsp;и так
        общеизвестно.</p>
      <p>Пусть&nbsp;<span class="math-tex">\(p(t)\)</span>&nbsp;равно вероятности
        того, что алгоритм не завершится к&nbsp;<span class="math-tex">\(i\)</span>-ой
        итерации и одновременно злоумышленники решили атаковать на&nbsp;<span class="math-tex">\(i\)</span>-ый
        раунд. То есть их атака произойдёт и будет успешна. Авторы работы утверждают,
        что&nbsp;<span class="math-tex">\(p(t) &lt; \frac{1}{(1-ε)t}\)</span>.
        Грубо говоря, они должны угадать число&nbsp;<span class="math-tex">\(i\)</span>&nbsp;из&nbsp;
        <span
        class="math-tex">\(t\)</span>&nbsp;возможных.</p>
      <p>&nbsp;</p>
  </body>

</html>